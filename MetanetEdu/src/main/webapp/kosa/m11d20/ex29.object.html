<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<script>
    /*
        JS 도 객체지향 언어입니다.
        객체지향이라는 것은 설계도라고 했는데요.
        설계도의 의미는 재사용성에서 의미를 갖습니다.
    */


    /*

	자바 설계도(클래스) => 재사용성
	class Product extends Object{
		private String carname="pony";
		public Product(){}
		public Product(String carname){
			this.carname= carname;
		}
		public void print(){
			System.out.println(this.carname);
		}
	}
​	메모리 load ... (new)
	Product p = new Product();
	Product p2 = new Product("pony2");

	p.print();
	p2.print();
	/////////////////////////////////////////////////////

	​

	javaScript >> 객체지향언어(OOP)

	클래스 정의 4가지 방법
	1. 프로토타입 방식 :  일반적인 클래스 제작 방법
 	  인스턴스마다 공통된 메서드를 공유해서 사용하는 장점
      Jquery 도 prototype 방식으로 설계
​

	function 클래스이름() {  //function Car{}
		this.프로퍼티1 = 초기값;
		this.프로퍼티2 = 초기값;

		메서드  ...기능  call(){}
	}

             (Object)
	클래스이름.prototype.메서드1 = function() {
              (원형,원시)
	}

	클래스이름.prototype.메서드2 = function() {

	}
	​

	var 인스턴스 = new 클래스이름();
	var carObj = new Car();   >> 메서드  ...기능  call(){}
	var carObj2 = new Car();  >> 메서드  ...기능  call(){}
	var carObj3 = new Car();  >> 메서드  ...기능  call(){}  why 같은 함수를 각각 따로따로 가지고 있지 ...

	​

	​


	2. 함수 방식 : 간단한 클래스 제작 시 사용
	인스턴스마다 메서드가 독립적으로 만들어지는 단점
	** 클래스 :  function Car(){ this.name = , this.age=}
	** 함수 :   function car(){}

	​

	function 클래스이름() {
		this.프로퍼티1 = 초기값;
		this.프로퍼티2 = 초기값;
		this.메서드1 = function() {

	    }
		this.메서드2 = function() {

		}
	}


	var 인스턴스 = new 클래스이름();
	var carObj = new Car();
	var carObj2 = new Car();
	var carObj3 = new Car();

	​
   ***************************************************************************

	3. 리터럴 방식 : 자바스크립트 객체 표기법 ( 이기종간의 데이터 호환 ) > JSON
	   클래스 만드는 용도는 아니며 주로 여러개의 매개변수를 그룹으로 묶어 함수의 매개변수로 보낼때
	   정의와 함께 인스턴스가 만들어지는 장점이 있음 단 인스턴스는 오직 하나
	   >>데이터 교환의 목적
      (초보자에게도 중요 ^^)
	  {"a":"데이터"}

	​

	​
    2015
	4. ECMA6 버전부터 : class 키워드 제공

	class Person {
		constructor(name) {
			this._name = name;

	     }
		sayHi() {
		console.log(`Hi! ${this._name}`);
		}
	}

	[ javascript 객체 생성 ]
	1.오브젝트 리터럴 방식 (객체를 만드는 방법): 클래스 생성과 동시에 객체가 만들어 져요
	1.1 리터럴 방식 >> 제일 간단한 방법 > var obj = {}; //var objarr = [] 배열
	1.2 JSON 표기 : {} >> JSON: JavaScript Object Notation

	ex) var myObj = { "name":"John", "age":31, "city":"New York" };

	TIP) JSON >> XML (텍스트 기반의 형식화된 문서 제공)
	XML :이기종간의 데이터 호환 (한 때는 서점 : xml webservice)


	다른 이야기 >> JSON
	객체지향언어 장점 : 설계도 (재사용성)
	*오브젝트 리터럴 방식 : 재사용을 지원하는 않는다 ....
	*설계도를 생성과 동시에 객체 생성(장점 : 편하고 , 빠르다 )
	*설계도를 미리 만들어 놓고 재사용하는 방식은 아니다
	*설계도당 하나의 객체만 생성 사용 (only object 라고 부르는 이유이다.)

	var product = {};  //Product p = new Product();

	var product2 = {제품명:'사과',년도:'2018',원산지:'대구'};


	var 인스턴스 ={
		프로퍼티:초기값,
		프로퍼티:초기값,
		.....
		메서드:function(){},   //잘 안만들어요 (DATA ....)
		메서드:function(){}....
	}

	​
	리터럴 방식 > 선언과 동시에 인스턴스 자동 생성
	var 인스턴스 = {}
	특징 : 생성자 존재하지 않는다.
	프로퍼티와 메서드만 정의 가능 (거의 다 프로퍼티만 사용합니다. 데이터 교환이 목적이기 때문이죠)
	단점 : 객체 하나 생성(재사용성 없다)
	접근방법 : 인스턴스이름.자원 >> product2.제품명
	*/

    /*
        프로퍼티 더블 quatation 은 하는게 좋긴한데, 안해도 됩니다
    */
    let Product = {제품명:'사과', 년도:'2000', 원산지:'대구'};
    console.log(Product);

    console.log(Product.제품명);
    console.log(Product.년도);
    console.log(Product.원산지);
    console.log(Product.toString()); //toString 을 하면 [Object Object] 라고 나오네요

    let Person = {name:'홍길동', addr:'서울시 강남구',
                  eat:function(food) {
                    document.write(this.name + " / " + this.addr + " / " + food + "냠냠");

                  }
                 };
    document.write("<hr>");
    Person.eat("사과");

    //js 에서는 요상한 문법이 있는데요. 객체의 속성을 지울 수 있습니다.
    delete(Product.년도);
    console.log(Product);

    // 개선된 for 문과 굉장히 궁합이 잘 맞는게 JSON 입니다.
    // JSON 도 배열이 아니긴 한데, 배열로 봐도 무방합니다.
    // 그래서 index 가 나오지 않습니다.
    // 객체를 for 문 돌릴 때는 변수를 key 로 받아와야 합니다.
    // key 를 가지고 value 값을 가져올 수 있게 됩니다.
    for(let key in Product) {
        console.log("key : " + key);
        console.log(Product[key]); //이렇게 배열에 index 가 아니라 key 를 넣어서 추출합니다.
    }

    let Member = {};
    Member.name = "hong"; //{name:"hong"} 을 한 것과 같습니다.
    Member.age = 100;
    Member.print = function() {
        document.write("<br>" + this.name + " / " + this.age + "<br>")
    }; //익명함수에서 자원에 대한 접근은 this.name 이렇게 접근
    Member.print();


    // JSON 은 이렇게 사용하면 간단하지만, 실생활에서 사용되는 데이터들은 매우 복잡합니다.
    // JSON 의 객체는 또 다른 객체를 가질 수 있기 때문이죠.
    // 또한 JSON 의 객체는 배열을 가질 수 있습니다.

    let Grade = {
        "list":{"hong":10, "kim":20, "park":30}, //value 값으로 객체가 올 수 있습니다.
        "show":function() { //value 값으로 익명 함수를 넣을 수 있습니다.
            for(let key in this.list) {
                document.write(key + " : " + this.list[key] + " ")
            }
        }
    };
    Grade.show();

    const listobj = Grade.list; //이렇게만 받으면 listobj 는 객체를 리턴받아서 객체가 됩니다.
    document.write(
        "<br>" + listobj.hong
    );
</script>


















































































